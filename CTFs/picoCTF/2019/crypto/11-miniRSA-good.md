
# Librerias
## Opcion 1 - Librerías en ambiente virtual 


```
python3 -m venv ~/venv
source ~/venv/bin/activate 
pip install libnum gmpy2 
```

## Opción 2 - En sistema completo
```
sudo apt update
sudo apt install python3-gmpy2

```


# Soluciones

Como tu exponente `e` es 3 (muy pequeño), la vulnerabilidad más probable es un **ataque de raíz cúbica** (conocido como _Stereotyped attack_ o _small e attack_).
Este ataque funciona si el mensaje original $m$ fue lo suficientemente pequeño como para que $m^3 < n$. Si eso ocurrió, el módulo no tuvo efecto, y por lo tanto $c = m^3$.
c = m ^ e mod n
c = m ^ 3
Para revertirlo, solo necesitamos calcular la raíz cúbica de $c$.
m = raiz3(c)

## Es una raiz cuadrada perfecta

```python

'''
Como tu exponente `e` es 3 (muy pequeño), la vulnerabilidad más probable es un **ataque de raíz cúbica** (conocido como _Stereotyped attack_ o _small e attack_).
Este ataque funciona si el mensaje original $m$ fue lo suficientemente pequeño como para que $m^3 < n$. 
Si eso ocurrió, el módulo no tuvo efecto, y por lo tanto $c = m^3$.
c = m ^ e mod n
c = m ^ 3
Para revertirlo, solo necesitamos calcular la raíz cúbica de $c$.
m = raiz3(c)
'''

import gmpy2

n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e = 3
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730

print("Calculando la raíz cúbica de c...")

m, es_exacta = gmpy2.iroot(c, 3)

if es_exacta:
    print("\n¡Raíz cúbica perfecta encontrada!")
    print(f"Mensaje (entero): {m}")
    flag = bytes.fromhex(hex(m)[2:]).decode()
    print(f"FLAG: {flag.decode()}")
else:
    print("\nNo se encontró una raíz cúbica perfecta.")
    print("Este ataque (small e) no funcionó.")


```

### Es una raiz cuadrada por aproximaciones

El ataque falló porque la suposición  m^3 < n  era incorrecta. El módulo _sí_ se aplicó. Esto nos lleva al **siguiente ataque más común** para `e=3`.

La nueva teoría (Ataque de k iterativa)

La ecuación real es : c = m^3 mod n

Por definición de la aritmética modular, esto significa que $m^3$ es igual a $c$ más algún múltiplo de $n$.

m^3 = c + k  * n

Donde k es un entero desconocido (k=1, k=2, etc) suele ser un numero pequeño

```python
 '''
El ataque falló porque la suposición  m^3 < n  era incorrecta. El módulo _sí_ se aplicó. Esto nos lleva al **siguiente ataque más común** para `e=3`.
La nueva teoría (Ataque de k iterativa)
La ecuación real es : c = m^3 mod n
Por definición de la aritmética modular, esto significa que $m^3$ es igual a $c$ más algún múltiplo de $n$.
m^3 = c + k  * n
Donde k es un entero desconocido (k=1, k=2, etc) suele ser un numero pequeño
'''

import gmpy2

n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e = 3
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808154558034707767377524500302754459807923331810585173010977657982069888996945830789092526932364658459034145456505057469113036134559745659079236466119515004648189278227777550415021840140147319061470183840214034417917161940379351273394212022847037696265532968684592354941479799473941357715953204487236888712642494877545201005807776354854390358015733495331101077851132489983665939643188064986446883595239842621440918456201787168234988410659153219277329426230136499096098072681939491840913961290536851217677043565743644469862992310241563891464225935615676242084658617931225618537173689559419607688905143683603007487996422560430269750305079282818976557285786253025774883158125978164878245223052992502106
k = 1

print(f"Iniciando búsqueda de k... (probando k=1, 2, 3...)")

while k < 10000: 
    
    target = c + (k * n)
    
    m, es_perfecta = gmpy2.iroot(target, 3)
    
    if es_perfecta:
        print(f"\n¡Éxito! Raíz cúbica perfecta encontrada con k = {k}")
        print(f"Mensaje (entero): {m}")
        print(f"FLAG: {bytes.fromhex(hex(m)[2:]).decode()}")
        break 
    
    if k % 100 == 0: print(f"Probando k = {k}...")
    
    k += 1 
    
if k == 10000:
    print("Se alcanzó el límite de k (10000) sin encontrar una solución.")
    print("Este ataque tampoco funcionó. Podría requerir un valor de k más alto o un ataque diferente (como Coppersmith).")

```